---
layout: post
title: 3.1 The Layout class
category: doc
---

h2. 3.1.1. The Layout class and subclasses

The @Layout@ class is a very flexible class that represents a set of components such as time samples or detectors that can assume several geometries.

<div class="definition">
|  @Layout@  | Most general layout |
|  @LayoutSpatialGrid@  | Rectangular layout |
|  @LayoutSpatialGridCircles@  | Rectangular layout of circles |
|  @LayoutSpatialGridSquares@  | Rectangular layout of squares |
|  @LayoutTemporal@ | Temporal layout |
</div>

The following snippet creates a grid of square detectors:

<div class="highlight_figure">

{% highlight python %}
>>> spacing = 0.001
>>> layout = LayoutSpatialGridSquares((16, 16), spacing, filling_factor=0.8)
>>> layout.plot()
{% endhighlight %}

<img src="{{site.baseurl}}/documentation/figures/layoutspatialgridsquares.png">
</div>

And this one, a grid of circles:

<div class="highlight_figure">

{% highlight python %}
>>> layout = LayoutSpatialGridCircles((16, 16), spacing)
>>> layout.plot()
{% endhighlight %}

<img src="{{site.baseurl}}/documentation/figures/layoutspatialgridcircles.png">
</div>

More generally, it is possible to specify the positions by hand:

<div class="highlight_figure">

{% highlight python %}
>>> center = [[[-1.5,  1.5], [0,  1], [1.5,  1.5]],
              [[-1,    0  ], [0,  0], [1,    0  ]],
              [[-1.5, -1.5], [0, -1], [1.5, -1.5]]]
>>> layout = LayoutSpatial((3, 3), center=center)
>>> layout.plot()
{% endhighlight %}

<img src="{{site.baseurl}}/documentation/figures/layout.png">
</div>


h2. 3.1.2. The packed and unpacked mirroring

A @Layout@ instance stores information about its components, such as the spatial location or any characteristics.

During a @Layout@ instanciation, some components may be discarded by using the @selection@ keyword, either because the components do not physically exist, or because they are not handled by the processing node if the work is distributed and executed in parallel. The components can also be ordered through the @ordering@ keyword.

In most cases, it is more convenient to travel the component characteristics in a 1-dimensional ordered array (the packed array, which does not contain the removed components), but in some other cases, it is more practical to access them through a multi-dimensional array mimicking the multi-dimensional layout (the unpacked array, which includes the removed components and those handled by other processes). The purpose of the @Layout@ class is to make these two access patterns transparent by mirroring them through special attributes that can be returned as packed or unpacked arrays. The special attributes are those that are passed as keywords in the @Layout@ instanciation.
Although only unpacked arrays can be passed during a @Layout@ instanciation, the @Layout@ instance only stores the packed values for efficiency reasons. These are then accessed as regular attributes and the mirrored unpacked values are accessed through the @all@ attribute.

{% highlight python %}
>>> shape = (3, 3)
>>> spacing = 1.
>>> selection=[[True, True, False ],
               [True, True, True],
               [True, True, True]]
>>> gain = [[1.0, 1.2, 1.5],
            [0.9, 1.0, 1.0],
            [0.8, 1.0, 1.0]]
>>> layout = LayoutSpatialGridSquares(shape, spacing, selection=selection,
                                      gain=gain)
>>> layout.shape
(3, 3)
>>> len(layout)
8
>>> len(layout.all)
9
>>> layout.all.removed
array([[False, False,  True],
       [False, False, False],
       [False, False, False]], dtype=bool)
>>> layout.gain
array([ 1. , 1.2, 0.9, 1. , 1. , 0.8, 1. , 1. ])
>>> layout.all.gain
array([[ 1. , 1.2, nan],
       [ 0.9, 1. , 1. ],
       [ 0.8, 1. , 1. ]])
>>> layout.center.shape, layout.all.center.shape
((8, 2), (3, 3, 2)
>>> layout.vertex.shape, layout.all.vertex.shape
((8, 4, 2), (3, 3, 4, 2)
{% endhighlight %}

Any external unpacked array can be packed:

{% highlight python %}
>>> values = np.arange(9).reshape(shape)
>>> layout.pack(values)
array([0, 1, 3, 4, 5, 6, 7, 8])
{% endhighlight %}

And conversely, any packed array can be unpacked. By default, for removed components, -1 is used for integer arrays and NaN otherwise, but this value can be specified with the @missing_value@ keyword.

{% highlight python %}
>>> layout.unpack(np.arange(8))
array([[ 0,  1, -1],
       [ 2,  3,  4],
       [ 5,  6,  7]])
>>> layout.unpack(np.arange(8, dtype=float) * 2)
array([[  0.,   2.,  nan],
       [  4.,   6.,   8.],
       [ 10.,  12.,  14.]])
{% endhighlight %}


h2. 3.1.3. Component ordering

In the previous examples, the ordering of the packed components follows the row-major storage of the unpacked arrays. Such ordering can be specified to follow a more appropriate numbering scheme. Let's consider an array of detectors which is made of 4 identical subarrays. Because cross-talk will mostly affect detectors of the same subarray, and because each subarray has its own readout electronic system, detectors in each subarray will have common artifacts, and it will be interesting to group them in the packed arrays. The new numbering of detectors is specified through the @ordering@ keyword.

<div class="highlight_figure">

{% highlight python %}
>>> i = arange(16).reshape((4, 4))
>>> index = np.vstack([np.hstack([i, i + 16]),
                       np.hstack([i + 32, i + 48])])
>>> layout = LayoutSpatialGridSquares((8, 8), 0.250, ordering=ordering)
>>> layout.plot()
>>> for (x, y), s in zip(layout.center, np.arange(len(layout))):
>>>     text(x, y, s, horizontalalignment='center', verticalalignment='center')
{% endhighlight %}

<img src="{{site.baseurl}}/documentation/figures/layoutordering.png">
</div>

The packed components are sorted according to their ranks in the ordering keyword. By specifying a negative value, it is possible to remove a component not already discarded by the @selection@ keyword. The @index@ attribute is a special one and is derived from the input @selection@ and @ordering@ keywords: it stores the unpacked row-major 1-dimensional indices of the packed components.

{% highlight python %}
>>> layout.index
array([ 0,  1,  2,  3,  8,  9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27,  4,
        5,  6,  7, 12, 13, 14, 15, 20, 21, 22, 23, 28, 29, 30, 31, 32, 33,
       34, 35, 40, 41, 42, 43, 48, 49, 50, 51, 56, 57, 58, 59, 36, 37, 38,
       39, 44, 45, 46, 47, 52, 53, 54, 55, 60, 61, 62, 63])
{% endhighlight %}

The @index@ unpacked attribute may be different from the input @ordering@ keyword if some removed components have a positive index value, or if the values in the index array don't start at zero or have gaps.


h2. 3.1.4. Layout splitting

h2. 3.1.5. Layout scattering

h2. 3.1.6. More on the special attributes

As already mentionned, for memory efficiency, only the packed arrays are stored in memory, which implies the following limitations:

* the component selection and ordering cannot be changed once the layout is created: the @index@ attribute is read-only.
* modifications of the values contained in an unpacked array are prevented by making the unpacked arrays read-only.

Given the following layout:

{% highlight python %}
>>> layout = Layout(10, selection=slice(5, 10), val=np.random.random(10))
{% endhighlight %}

this is the wrong way to make an assignment:

{% highlight python %}
>>> layout.all.val[5] = 10
ValueError: assignment destination is read-only
{% endhighlight %}

This one is correct:

{% highlight python %}
>>> unpacked = layout.all.val.copy()
>>> unpacked[5] = 10
>>> layout.all.val = unpacked
{% endhighlight %}

but the following is better, because it avoid copies:

{% highlight python %}
>>> layout.val[0] = 10
{% endhighlight %}

Special attributes can also be functions, in order to decrease the memory footprint. In this case, the function is called each time the attribute is accessed. For instance, the @LayoutSpatialGrid@ class uses such a mechanism for the @row@ and @column@ special attributes to avoid storing them in memory.

These functions must return packed arrays. They can have:
* no argument, by using the parent scope variables. Note that Python's handling of closure may be unintuitive (to be polite) and is a frequent source of mistakes. It is necessary to check that these parent scope variables are not reassigned to another value after the function is defined, since the new values would be the ones used in the function.

{% highlight python %}
>>> x = [0, 7, 14]
>>> layout = Layout(3, val=lambda: x)
>>> layout.val
[0, 7, 14]
{% endhighlight %}

* one argument, which is then the layout itself. Continuing the example in the previous section of a @Layout@ made of 4 subarrays, we can define a special attribute @subarray@ using a function that will return to which subarray a detector belongs.

<div class="highlight_figure">

{% highlight python %}
>>> layout = LayoutGridSquares((8, 8), 0.250, ordering=ordering,
                               subarray=lambda self: self.index // 16 + 1)
>>> layout.plot()
>>> for (x, y), s in zip(layout.center, layout.subarray):
>>>     text(x, y, s, horizontalalignment='center', verticalalignment='center')
{% endhighlight %}

<img src="{{site.baseurl}}/documentation/figures/layoutsubarray.png">
</div>


* or more, in which case the special attribute remains a function:

{% highlight python %}
>>> selection = [True, True, True, False]
>>> layout = Layout(4, selection=selection, val=[0, 7, 14, 21], func=lambda s, v: s.val+v)
>>> layout.func(10)
np.array([10, 17, 24])
>>> layout.all.func(10)
np.array([10, 17, 24, -1])
{% endhighlight %}

A special packed attribute can also be a scalar, in which case only the unpacked mirrored array is dimensional.
